# Practice Questions

1. *What is 4! (that is, the factorial of 4)?*

The factorial of 4 is the product of 4 x 3 x 2 x 1. Therefore, the factorial of 4 is 24.

2. *How can you use the factorial of (n - 1) to calculate the factorial of n?*

We have just seen that the factorial of 4 is equal to the product of 4 x 3 x 2 x 1. Likewise, the factorial of 5 is equal to the product of 5 x 4 x 3 x 2 x 1. In general, the factorial of any given number n is equal to the product of  n x (n - 1) x (n - 2) x ..... x 1. Thus, it is clear that the factorial of 5, for example, is simply the result of multiplying 5 by the factorial of 4 (that is, 4 x 3 x 2 x 1). So one can calculate the factorial of any number n simply by calculating the factorial of (n - 1) and then multiplying the result by n.

3. *What is the critical weakness of the recursive factorial function?*

The critical weakness of a recursive function to calculate the factorial of any number is that it runs the risk of creating a stack overflow. The reason for this is how the recursive function is structured:

``` ruby
def factorial(n)
  return 1 if n == 1

  return n * factorial(n - 1)
end
```

Suppose we call this function and pass in 3 as the value of n. Since n != 1, we skip the base case and go to the recursive case. This case returns n * factorial(n - 1), that is, 3 * factorial(3 - 1). But the return value itself *calls* the function, so it doesn't actually *return* anything until factorial(3 - 1) executes. Because n != 1 in that case, we once again skip the base case and go to the recursive case, where we return n * factorial(n - 1), that is, 2 * factorial(2 - 1). Once again, the return value *calls* the function, and so does not *return* anything until factorial(2 - 1) executes. Finally n == 1, so we hit the base case and return 1, at which point we work our way back (as it were), performing the appropriate multiplications until we get the factorial of 3.

The problem with this structure is that with *larger* numbers, say, 1000 or higher, we are likely to cause a stack overflow. The function keeps *calling* itself without *returning* anything as tries to calculate the factorial of each successively smaller integer until it finally hits the base case of 1. Since frame objects are only popped off the call stack when a function *returns a value*, this means the stack continues to add frame objects with each recursive call of the function without popping any off until we hit the base case. That can lead to a stack overflow for sufficiently higher values.

4. *What are the first five numbers of the Fibonacci sequence?*

Each number in the Fibonacci sequence is generated by adding together the previous two numbers in the sequence. Thus, the first five numbers in that sequence are: 1, 1, 2, 3, 5.

5. *What two numbers do you add to the get the nth number of the Fibonacci sequence?*

To get the nth number of the Fibonacci sequence, one must add together these numbers: n - 1 and n - 2.

6. *What is the critical weakness of the recursive Fibonacci function?*

The critical weakness of the recursive Fibonacci function depends on its structure:

``` ruby
def fibonacci(num)
  return 1 if [1,2].include?(num)

  fibonacci(n - 2) + fibonacci(n - 1)
end
```

Suppose you want to calculate the 10th number in the Fibonacci sequence, so that you pass in 10 as the value of `num`. Since `[1,2]` does not include 10, we skip the base case and go to the recursive case. This tells us to calculate the value of fibonacci(n - 2) + fibonacci(n - 1), that is, the value of fibonacci(8) + fibonacci(9). When fibonacci(8) is called, we once again skip the base case and go to the recursive case, where we attempt to calculate the value of fibonacci(n - 2) + fibonacci(n - 1), that is, fibonacci(6) + fibonacci(7). And so on.

The problem is that we *also* must perform these calculations for fibonacci(9). When *this* is called, we once again skip the base case and go to the recursive case, where we attempt to calculate the value of fibonacci(n - 2) + fibonacci(n - 1), that is, fibonacci(7) + fibonacci(8). *But we have already done both of those things!*

Thus, the problem with the recursive Fibonacci function is that it has *two* recursive calls, which leads to a massive amount of redundancy as each recursive call works its way down to the base case. This makes the function highly inefficient.

7. *What does an iterative algorithm always use?*

An iterative algorithm always uses a *loop*.

8. *Is it always possible to convert an iterative algorithm into a recursive one?*

Yes.

9. *Is it always possible to convert a recursive algorithm into an iterative one?*

Yes.

10. *Any recursive algorithm can be performed iteratively by using what two things?*

A recursive algorithm can be re-written as an iterative algorithm by making use of two things: (a) a *loop* and (b) a *stack* data structure such as an array. The stack data structure mimics the *call stack*, while the loop mimics the recursive function calls of the recursive algorithm.

11. *What three features do programming problems that are suitable to recursive solutions have?*

Typically, a programming problem is suitable to a recursive solution if the following three conditions obtain: (a) it has a *tree-like* structure, (b) it involves *backtracking*, and (c) it is not likely to cause a stack overflow.

12. *When is recursion required to solve a programming problem?*

Never. Any problem that can be solved with recursion *can* be solved iteratively. But some scenarios are better-suited for recursive solutions than others, and in these cases a recursive solution is *preferred*, but not *required*.